--!strict
export type RunResult = ({
	ok: true,
	--- cleaned standard output of the process, shouldn't have trailing newlines or whitespace
	out: string,
	--- the raw standard output (stdout) generated by the process; this includes trailing newlines and whitespace
	stdout: string,
	--- the raw standard error (stderr) generated by the process; this includes trailing newlines and whitespace
	stderr: string,
} | {
	ok: false,
	err: string,
	stdout: string,
	stderr: string,
}) & {
	--- Returns the `RunResult`'s `stdout` if it was successful, stripping trailing whitespace and newlines.
	--- Errors if the RunResult was unsuccessful.
	unwrap: (self: RunResult) -> string,
	--[=[
		Returns the `RunResult`'s `stdout` if it was successful, otherwise returns a default value.

		The `default` can be either a string or a function that takes in the `RunResult` and returns a string.
		If you provide a `default` function, `:unwrap_or` will return what it returns.
	]=]
	unwrap_or: (self: RunResult, default: string | (result: RunResult) -> string) -> string
}

export type RunOptions = {
	program: string,
	--- an optional list of arguments to pass into the program; on Windows, you should use this instead of trying to pass whitespace-separated arguments in `program`
	args: { string }?,
	--- specify a shell to run the program with; otherwise runs it as a bare process with no shell
	shell: string?,
	--- path to the the working directory you want your command to execute in, defaults to your shell's cwd
	cwd: string?,
}

export type SpawnOptions = {
	program: string,
	--- an optional list of arguments to pass into the program; on Windows, you should use this instead of trying to pass whitespace-separated arguments in `program`
	args: { string }?,
	shell: string?,
	--- path to the the working directory you want your command to execute in, defaults to your shell's cwd
	cwd: string?,
	--[=[
		A `ChildProcessStream` captures incoming bytes from your `ChildProcess`' output streams (either stdout or stderr),
		and caches them in its `inner` buffer. Each stream is spawned in a separate Rust thread to facilitate
		consistently nonblocking, dependable reads, allowing most `ChildProcess.stream:read` methods to be fully nonblocking unless
		specifically requested otherwise.

		## Options

		### Stream capacity

		To prevent memory leaks (if you spawn a child process and never read from stdout or stderr), each stream's inner buffer capacity is capped,
		and adjustable by setting `stdout_capacity` and `stderr_capacity`, respectively.

		By default, `stdout` streams are capped to 2048 bytes and `stderr` streams to 1028.

		When more bytes are read from the stream than can fit in the buffer, old bytes are drained (and lost!) so the buffer
		can remain the same size (preventing memory leaks).

		By increasing stream capacity, you allow more bytes to be read/consumable at the same time without losing data if you infrequently read from the buffer.
		
		If you're reading from stdout in really tight loops, and your ChildProcess only spits out data in chunks of 512 bytes at a time, you can definitely
		decrease your stream capacity to 512 bytes (or slightly larger just in case), to reduce allocations.

		## Truncation

		By default, seal truncates bytes from the front of inner, causing old data to be lost first. Set `truncate == "back` to override this behavior (and preserve old data at the expense of incoming data)
	]=]
	stream: {
		--- inner buffer capacity of `ChildProcess.stdout`, default 2048
		stdout_capacity: number?,
		--- inner buffer capacity of `ChildProcess.stderr`, default 1024
		stderr_capacity: number?,
		--- what side of stdout should be truncated when full? defaults to "front"
		stdout_truncate: ("front" | "back")?,
		--- what side of stderr should be truncated when full? defaults to "front"
		stderr_truncate: ("front" | "back")?,
	}?,
}

export type ChildProcessStream = setmetatable<{
	--[=[
		Reads any available bytes in the stream, returning the bytes read as a Luau string without any intermediate utf-8 conversion.

		When called without a `duration`, this function almost never blocks the current VM (Rust Thread), and will only return any bytes that are available.
		
		Note: if called within 1ms of spawning the `ChildProcess`, this function blocks for exactly 10ms to ensure there's something to read.
		To disable this feature, explicitly pass `0.0` as the duration.
		
		If a `duration` is provided, blocks the current VM for `duration` (in seconds), allowing for enough time to read any new incoming bytes.

		## Usage

		### Use a loop to `:read()` without specifying a duration:

		```luau
		local watcher = process.spawn {
			program = "somewatcher",
			args = { somefile }
		}

		while watcher:alive() do
			local content = watcher.stdout:read()
			if content then
				print(`got {content}!`)
			end
		end
		```

		### Use a `duration` to `:read` right after spawning a `ChildProcess`:

		```luau
		local child = process.spawn {
			program = `seal {myfilename}`,
			shell = "bash",
		}
		
		local maybe_hello = child.stdout:read(0.05)
		if string.match(maybe_hello:lower(), "hello world") then
			print("hello worlded")
		end
		```

		To read into a buffer (to build up strings without concatenation overhead), use `:readbytes` instead.
	]=]
	read: (self: ChildProcessStream, duration: number?) -> string?,
	--[=[
		Reads exactly `count` bytes from the stream, almost never blocking the current VM (Rust Thread) unless a `duration` is provided. 

		If fewer than `count` bytes are available in the stream, this function returns `nil` and zero bytes are consumed (you can try again with a smaller `count`).

		If a `duration` (in seconds) is provided, blocks the current VM for exactly `duration` before reading, allowing for enough time
		to read new data to the stream.

		This function has the same just-spawned blocking behavior as :read, ensuring there's something to read upon spawning a child process.
		Disable this by explicitly passing 0.0.
		
		Returns the byte(s) read as a Luau string (without any intermediate utf-8 conversion); to read into a buffer instead, use `:readbytes_exact`.
	]=]
	read_exact: (self: ChildProcessStream, count: number, duration: number?) -> string?,
	--[=[
		Keep reading from the stream until encountering search term terminal string `term`.

		By default, blocks the current VM (Rust Thread) until `term` is found, and doesn't consume any bytes from the stream until `term` is found.

		If `term` is an empty string, reads from the stream until the process exits ("read to end" behavior).

		If `inclusive == true`, includes `term` with the resulting string, otherwise strips it from the result.

		If `timeout` is specified and `allow_partial` is unspecified or false, and `term` isn't found before `timeout` seconds elapse, returns `nil` without consuming any bytes from the stream.

		If `timeout` is specified and `allow_partial` is true, then consumes and returns the entire contents of the stream when `timeout` seconds elapse.

		`allow_partial` doesn't do anything if `timeout` is unspecified.
	]=]
	read_to: (self: ChildProcessStream, term: string, inclusive: boolean?, timeout: number?, allow_partial: boolean?) -> string?,
	--[=[
		Reads any available bytes in the stream to the target buffer at `offset` (default 0), until zero bytes are left in the stream or the buffer is full.
		
		If any bytes were read successfully, returns the number of bytes read, otherwise returns nil.

		This function will almost never block unless a `duration` is specified; if one is, it'll block the current VM for exactly `duration`.
		
		This function has the same just-spawned blocking behavior as :read, ensuring there's something to read upon spawning a child process.
		Disable this by explicitly passing 0.0 as the `duration`.

		## Usage

		```luau
		local result = buffer.create(1024)
		local offset = 0
		while child:alive() and offset < 1024 do
			local count = child.stdout:readbytes(result, offset)
			if count then
				offset += count
			end
		end
		print(buffer.tostring(result))
		```
		Errors if offset >= the target buffer's length to prevent overfilling the target buffer
	]=]
	readbytes: (self: ChildProcessStream, target: buffer, offset: number?, duration: number?) -> number?,
	--[=[
		Reads exactly `count` bytes into `target` at `offset` (default 0), consuming the bytes only when successfully read.

		If `duration` is set, blocks the current VM for exactly `duration` seconds before reading from the stream.
		This allows the writer time to add more data into the stream.

		Returns `success`, representing whether any data was written into the target buffer, and `remaining`, an optional number
		representing how many bytes are left in the stream:

		- `(success: false, remaining: nil)` if the stream is empty,
		- `(success: false, remaining: number)` if the stream isn't empty but fewer than `count` bytes are available,
		- `(success: true, remaining: number)` if `count` bytes were successfully written to the stream, and `remaining` bytes are still available,
		- `(success: true, remaining: nil)` if `count` bytes were successfully written to the buffer, and the stream is now empty.

		This function has the same just-spawned blocking behavior as :read, ensuring there's something to read upon spawning a child process.
		Disable this by explicitly passing 0.0 as the `duration`.
	]=]
	readbytes_exact: (self: ChildProcessStream, count: number, target: buffer, offset: number?, duration: number?) -> (boolean, number?),
	--[=[
		Iterate over the lines in the stream, blocking the current VM (Rust Thread) until all lines are read or the timeout has been reached.

		If a `timeout` is specified, `:lines()` will stop iterating once a line hasn't been seen for `timeout` seconds, allowing you to
		early-interrupt when new data hasn't been seen for a while.

		## Usage

		### In a loop:

		```luau
		local process = require("@std/process")
		local child = process.spawn({
			program = "someutil --watch",
			shell = "sh",
		})
		
		for line in child.stdout:lines() do
			local thing_changed = line:match("([%w]+) changed!")
			print(`Change detected: {thing_changed}`)
		end
		```

		### As iterator:

		```luau
		local process = require("@std/process")
		local child = process.spawn {
			program = "somewatcher --watch",
			shell = "sh",
		}

		local next_line = child.stdout:lines()
		local first_line = next_line()
		local second_line = next_line()
		```
	]=]
	lines: (self: ChildProcessStream, timeout: number?) -> (() -> string),
	-- advanced methods:
	--[=[
		Iterate over the stream with the same semantics as generalized iteration, except with more granular options:

		To prevent nonterminating iteration without an explicit `break`, you can provide a `timeout`, which stops iteration
		when new data hasn't been seen for `timeout` seconds.

		When iteration attempts to read from an empty stream, it waits `write_delay_ms` milliseconds (default 5) before trying again.
		Increase this value if you see weird chunking behavior (you want to see more data each iteration), 
		or decrease this value if your child process outputs quickly and you want iteration to go faster.
	]=]
	iter: (self: ChildProcessStream, timeout: number?, write_delay_ms: number?) -> (() -> string),
	-- reflection options
	--- Returns the current size/length of the inner buffer
	size: (self: ChildProcessStream) -> number,
	--- Returns the maximum capacity of the inner buffer, after which bytes will be truncated
	capacity: (self: ChildProcessStream) -> number,
}, {
	__iter: (self: ChildProcessStream) -> () -> string
}>


type ChildProcessStdin = {
	write: (self: ChildProcessStdin, data: string) -> nil
}

export type ChildProcess = {
	id: number,
	alive: (self: ChildProcess) -> boolean,
	kill: (self: ChildProcess) -> (),
	stdout: ChildProcessStream,
	stderr: ChildProcessStream,
	stdin: ChildProcessStdin,
}

type process = {
	--[=[
	Runs a program, yields until it completes, and returns its results.

	Takes a RunOptions table:
	```luau
	type RunOptions = {
		program: string,
		--- optional args you want to pass
		args: { string }?,
		--- the name or path of the shell, omit to run without shell
		shell: string? 
		--- path to the the working directory you want your command to execute in
		cwd: string?,
	}
	```

	### Usage
	```luau
	local process = require("@std/process")
	local result = process.run {
		program = "lune",
		args = {"run", somefile},
	}
	if result.ok then
		print(result.stdout)
	end
	```
	]=]
	run: (options: RunOptions) -> RunResult,
	--[=[
	Launches a shell command in a child process.

	Uses the same shell you're using to run `seal` (so your aliases should available, except on Windows,
	where it's a bit more complicated).

	To find your current shell, `process.shell` checks your `SHELL` environment variable, and
	if not found, defaults to `sh` on Unix-like systems and `powershell` (Windows PowerShell) on Windows.

	On Windows, arguments aren't necessarily separated by whitespace like on Linux, and every program
	might accept arguments in a slightly different way, so be careful and use `process.run` with `args`
	when in doubt.
	
	Note that spawning processes (even starting the `powershell` process) is slow on Windows,
	so I recommend sticking to `process.run` with `args` unless you need shell behavior for your usecase.

	### Usage
	```luau
	local process = require("@std/process")
	local file_stuff: {string} = process.shell("ls -l"):unwrap()
	print(file_stuff)
	```
	]=]
	shell: (command: string) -> RunResult,
	--[=[
	Spawns a long-running process in a non-blocking manner, returns a `ChildProcess` that contains handles to the spawned process' stdout, stderr, and stdin.

	## Usage
	```luau
	local process = require("@std/process")
	local child = process.spawn({
		program = "someutil --watch",
		shell = "sh",
	})
	
	for line in child.stdout:lines() do
		local thing_changed = line:match("([%w]+) changed!")
		print(`Change detected: {thing_changed}`)
	end
	```
	]=]
	spawn: (options: SpawnOptions) -> ChildProcess,
	setexitcallback: ((number) -> ()) -> (),
	exit: (code: number?) -> never,
}

return {} :: process
