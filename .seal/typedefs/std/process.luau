--!strict
export type RunResult = ({
	ok: true,
	--- cleaned standard output of the process, shouldn't have trailing newlines or whitespace
	out: string,
	--- the raw standard output (stdout) generated by the process; this includes trailing newlines and whitespace
	stdout: string,
	--- the raw standard error (stderr) generated by the process; this includes trailing newlines and whitespace
	stderr: string,
} | {
	ok: false,
	err: string,
	stdout: string,
	stderr: string,
}) & {
	--- Returns the `RunResult`'s `stdout` if it was successful, stripping trailing whitespace and newlines.
	--- Errors if the RunResult was unsuccessful.
	unwrap: (self: RunResult) -> string,
	--[=[
		Returns the `RunResult`'s `stdout` if it was successful, otherwise returns a default value.

		The `default` can be either a string or a function that takes in the `RunResult` and returns a string.
		If you provide a `default` function, `:unwrap_or` will return what it returns.
	]=]
	unwrap_or: (self: RunResult, default: string | (result: RunResult) -> string) -> string
}

export type RunOptions = {
	program: string,
	--- an optional list of arguments to pass into the program; on Windows, you should use this instead of trying to pass arguments in `program`
	args: { string }?,
	--- specify a shell to run the program with; otherwise runs it as a bare process with no shell
	shell: string?,
	--- path to the the working directory you want your command to execute in
	cwd: string?,
}

type ChildProcessStdout = {
	--[=[
		Reads exactly `buffer_size` bytes from the child process' stdout, returning it as a Luau string (without any intermediate utf-8 conversion).

		This method returns `nil` if it was unable to read *exactly* the number of bytes requested, including when it
		encounters an `EOF` before completely filling its buffer.

		If used within a `while` loop, I recommend using an extremely small `buffer_size` like 1, because it's extremely easy to lose data
		otherwise.

		Depending on your usecase, consider using `:read_to` instead.
	]=]
	read_exact: (self: ChildProcessStdout, buffer_size: number?) -> string?,
	--[=[
		Iterate over the lines of the child process' stdout, blocking the current VM (Rust Thread) until all lines are read.

		## Usage

		```luau
		local process = require("@std/process")
		local child = process.spawn({
			program = "someutil --watch",
			shell = "sh",
		})
		
		for line in child.stdout:lines() do
			local thing_changed = line:match("([%w]+) changed!")
			print(`Change detected: {thing_changed}`)
		end
		```
	]=]
	lines: (self: ChildProcessStdout) -> (() -> string)
}

type ChildProcessStderr = {
	--[=[
		Reads exactly `buffer_size` bytes from the child process' stderr, returning it as a Luau string (without any intermediate utf-8 conversion).

		This method returns `nil` if it was unable to read *exactly* the number of bytes requested, including when it
		encounters an `EOF` before completely filling its buffer.

		If used within a `while` loop, I recommend using an extremely small `buffer_size` like 1, because it's extremely easy to lose data
		otherwise.

		Depending on your usecase, consider using `:read_to` instead.
	]=]
	read_exact: (self: ChildProcessStderr, buffer_size: number?) -> string?,
	--[=[
		Iterate over the lines of the child process' stderr, blocking the current VM (Rust Thread) until all lines are read.
	]=]
	lines: (self: ChildProcessStderr) -> (() -> string)
}

type ChildProcessStdin = {
	write: (self: ChildProcessStdin, data: string) -> nil
}

export type ChildProcess = {
	id: number,
	alive: (self: ChildProcess) -> boolean,
	kill: (self: ChildProcess) -> nil,
	stdout: ChildProcessStdout,
	stderr: ChildProcessStderr,
	stdin: ChildProcessStdin,
}

type process = {
	--[=[
	Runs a program, yields until it completes, and returns its results.

	Takes a RunOptions table:
	```luau
	type RunOptions = {
		program: string,
		--- optional args you want to pass
		args: { string }?,
		--- the name or path of the shell, omit to run without shell
		shell: string? 
		--- path to the the working directory you want your command to execute in
		cwd: string?,
	}
	```

	### Usage
	```luau
	local process = require("@std/process")
	local result = process.run {
		program = "lune",
		args = {"run", somefile},
	}
	if result.ok then
		print(result.stdout)
	end
	```
	]=]
	run: (options: RunOptions) -> RunResult,
	--[=[
	Launches a shell command in a child process.

	Uses the same shell you're using to run `seal` (so your aliases should available, except on Windows,
	where it's a bit more complicated).

	To find your current shell, `process.shell` checks your `SHELL` environment variable, and
	if not found, defaults to `sh` on Unix-like systems and `powershell` (Windows PowerShell) on Windows.

	On Windows, arguments aren't necessarily separated by whitespace like on Linux, and every program
	might accept arguments in a slightly different way, so be careful and use `process.run` with `args`
	when in doubt.
	
	Note that spawning processes (even starting the `powershell` process) is slow on Windows,
	so I recommend sticking to `process.run` with `args` unless you need shell behavior for your usecase.

	### Usage
	```luau
	local process = require("@std/process")
	local file_stuff: {string} = process.shell("ls -l"):unwrap()
	print(file_stuff)
	```
	]=]
	shell: (command: string) -> RunResult,
	--[=[
	Spawns a long-running process in a non-blocking manner, returns a `ChildProcess` that contains handles to the spawned process' stdout, stderr, and stdin.

	## Usage
	```luau
	local process = require("@std/process")
	local child = process.spawn({
		program = "someutil --watch",
		shell = "sh",
	})
	
	for line in child.stdout:lines() do
		local thing_changed = line:match("([%w]+) changed!")
		print(`Change detected: {thing_changed}`)
	end
	```
	]=]
	spawn: (options: RunOptions) -> ChildProcess,
	setexitcallback: ((number) -> ()) -> (),
	exit: (code: number?) -> never,
}

return {} :: process
